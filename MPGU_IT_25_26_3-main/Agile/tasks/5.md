## Agile 5. Основы ООП на С# (максимальный балл 5 + 2, дедлай 14.10.2025 включительно)

# Критерии оценивания (макс. 5+2 баллов)

---

1. **Объявление интерфейсов (1 балл)**

   * Интерфейсы корректно определены.
   * Все свойства и методы, указанные в условии, присутствуют.

2. **Реализация по умолчанию (если требуется) (1 балл)**

   * Реализация по умолчанию в интерфейсе есть.
   * Логика соответствует условию задачи.

3. **Реализация классов (2 балла)**

   * Каждый класс корректно реализует указанные интерфейсы.
   * Свойства работают через приватные поля.
   * Методы реализованы в соответствии с логикой задачи.
   * При необходимости методы интерфейса переопределены.

4. **Тестовый код (1 балл)**

   * Созданы объекты требуемых классов.
   * Продемонстрирована работа методов и свойств.
   * Вывод или поведение соответствует описанному сценарию.

5. **Реализация (до 2 баллов, дополнительно)** 

   * Субъективно оценивается реализация дополнительной функциональности, не описанной в условии явно, но согласующейся с контекстом.

---

### Штрафы за «грязный» код (каждый пункт −1 балл)

* Длинные строки (любая строка кода ≥ 80 символов).
* Несоответствие C#-стилю (snake_case в публичном API и т. п.).
* Магические константы вместо const/readonly/настроек.
* Дублирование кода, неочевидные побочные эффекты.
* Неверные модификаторы доступа, игнорирование null-проверок/инвариантов.

---

## Задача 1: "Игровой персонаж"

**Контекст:**
Вы проектируете систему для ролевой игры. У разных персонажей могут быть разные свойства и поведение, но они должны быть управляемы через интерфейсы.

**Требования:**

1. Создайте интерфейс **ICharacter**:

   * Свойство: `string Name` — имя персонажа.
   * Свойство: `int Health` — уровень здоровья.
   * Метод: `void TakeDamage(int amount)` — уменьшить здоровье.
   * Реализация по умолчанию для `TakeDamage()`: уменьшает здоровье на `amount`, но не позволяет опуститься ниже нуля.

2. Создайте интерфейс **IWarrior**:

   * Свойство: `int Strength` — сила удара.
   * Свойство: `int Armor` — броня.
   * Метод: `void Attack(ICharacter target)` — атаковать другого персонажа, нанося урон равный силе.

3. Создайте два класса:

   * **Villager** (крестьянин): реализует только `ICharacter`.
   * **Knight** (рыцарь): реализует **ICharacter** и **IWarrior**.

4. При реализации интерфейсов в классах:

   * Все свойства должны хранить данные через приватные поля.
   * В классе `Villager` метод `TakeDamage()` может использовать стандартную реализацию из интерфейса **ICharacter**.
   * В классе `Knight` метод `TakeDamage()` нужно **переопределить**, чтобы учесть броню:

     * урон уменьшается на значение `Armor`;
     * если после этого урон ≤ 0, здоровье не изменяется;
     * иначе урон вычитается из здоровья, но здоровье не падает ниже нуля.
   * Метод `Attack()` в рыцаре должен уменьшать здоровье цели на `Strength` и выводить сообщение:
     `"Knight {Name} атакует {target.Name} и наносит {Strength} урона"`.

5. Напишите тестовый код, который:

   * Создаёт `Villager` и `Knight`.
   * Рыцарь атакует крестьянина несколько раз.
   * Затем крестьянин "атакует" рыцаря (через вызов `TakeDamage` напрямую), и видно, что броня снижает урон.

---

## Задача 2: «Банковские счета»

**Контекст:**
Проектируете модели для банковской системы. Нужна базовая работа со счетом и возможность переводов.

**Требования:**

1. Интерфейс **IAccount**

* Свойства: `string OwnerName`, `int Balance`.
* Метод: `void Withdraw(int amount)`.
* Реализация по умолчанию: уменьшает `Balance` на `amount`, но не ниже 0 (если `amount > Balance`, списать всё до 0).

2. Интерфейс **ITransfer**

* Свойство: `int DailyLimit`.
* Метод: `void TransferTo(IAccount target, int amount)` — перевести средства на другой счёт.

3. Классы

* **SavingsAccount** — реализует только `IAccount`.
* **PremiumAccount** — реализует `IAccount` и `ITransfer`.

4. Реализация в классах

* Свойства через приватные поля.
* `SavingsAccount` использует дефолтный `Withdraw`.
* В `PremiumAccount` переопределите `Withdraw`, учитывая лимит:

  * Если `amount > DailyLimit`, списать только `DailyLimit`.
  * Иначе вести себя как дефолтная реализация.
* В `TransferTo` у `PremiumAccount`:

  * Внутри вызвать собственный `Withdraw(amount)`.
  * Если после `Withdraw` баланс уменьшился хотя бы на 1, зачислить на `target.Balance` фактически списанную сумму.

5. Тест

* Создать `SavingsAccount` и `PremiumAccount`.
* Проверить `Withdraw` с превышением лимита у премиум-счёта.
* Проверить `TransferTo` и изменение балансов.

---

## Задача 3: «Редактор задач печати»

**Контекст:**
Система очереди печати для офиса. Базовая модель задания и приоритезация.

**Требования:**

1. Интерфейс **IJob**

* Свойства: `string Title`, `int Pages`, `bool IsCanceled`.
* Метод: `void Cancel()` — пометить задание отменённым.
* Реализация по умолчанию: `IsCanceled = true`.

2. Интерфейс **IPrioritizable**

* Свойство: `int Priority` (чем больше — тем выше приоритет).
* Метод: `void Bump()`

3. Классы

* **SimpleJob** — реализует только `IJob`.
* **UrgentJob** — реализует `IJob` и `IPrioritizable`.

4. Реализация в классах

* Свойства через приватные поля.
* `SimpleJob` использует дефолтный `Cancel()`.
* В `UrgentJob` переопределите `Cancel()` с учётом приоритета:

  * Если `Priority >= 5`, отмена запрещена (оставить `IsCanceled = false`).
  * Иначе выполнить дефолтную отмену.
* Метод `Bump()` увеличивает `Priority` на 1.

5. Тест

* Создать `SimpleJob` и `UrgentJob`.
* Проверить: высокий приоритет у `UrgentJob` блокирует отмену; при низком — отмена проходит.
* Продемонстрировать работу `Bump()`.

---

## Задача 4: «Отправления и отслеживание»

**Контекст:**
Логистическая система: посылки и их трекинг.

**Требования:**

1. Интерфейс **IParcel**

* Свойства: `string Code`, `int Weight`, `bool IsDamaged`.
* Метод: `void MarkDamaged(int severity)` — пометить повреждение.
* Реализация по умолчанию: если `severity > 0`, `IsDamaged = true`.

2. Интерфейс **ITrackable**

* Свойство: `string TrackingId`.
* Метод: `void AddCheckpoint(string note)` — добавить отметку в трек.

3. Классы

* **BasicParcel** — реализует только `IParcel`.
* **CourierParcel** — реализует `IParcel` и `ITrackable`.

4. Реализация в классах

* Свойства через приватные поля.
* `BasicParcel` использует дефолтный `MarkDamaged`.
* В `CourierParcel` добавьте свойство `int Fragility` (0–10).
* Переопределите `MarkDamaged(int severity)`:

  * Эффективная тяжесть = `severity + Fragility/3` (целочисленно).
  * Если эффективная тяжесть > 0, `IsDamaged = true`.
* `AddCheckpoint` должен выводить сообщение `"[{TrackingId}] {note}"` (или логировать).

5. Тест

* Создать `BasicParcel` и `CourierParcel` с разной `Fragility`.
* Проверить, что у курьерской посылки даже небольшой `severity` может пометить груз повреждённым из-за хрупкости.
* Вызвать `AddCheckpoint` и убедиться в корректном тексте.

---

## Задача 5: «Товары и склад»

**Контекст:**
Онлайн-магазин: расчёт скидок и резервирование на складе.

**Требования:**

1. Интерфейс **IProduct**

* Свойства: `string Name`, `int Price`.
* Метод: `void ApplyDiscount(int percent)` — применить скидку в процентах.
* Реализация по умолчанию: уменьшить `Price` на `percent%`, не опуская ниже 0.

2. Интерфейс **IStockItem**

* Свойство: `int Stock`.
* Метод: `bool Reserve(int qty)` — зарезервировать `qty` единиц (вернуть `true/false`).

3. Классы

* **SimpleProduct** — реализует только `IProduct`.
* **WarehouseItem** — реализует `IProduct` и `IStockItem`.

4. Реализация в классах

* Свойства через приватные поля.
* `SimpleProduct` использует дефолтный `ApplyDiscount`.
* В `WarehouseItem` добавьте свойство `int MinPrice` — минимально допустимая цена.
* Переопределите `ApplyDiscount(percent)`:

  * Рассчитать новую цену как в дефолтной реализации.
  * Если новая цена < `MinPrice`, установить `Price = MinPrice`.
* В `Reserve(qty)` уменьшать `Stock`, если хватает, и возвращать `true`, иначе — `false`.

5. Тест

* Создать `SimpleProduct` и `WarehouseItem` с заданным `MinPrice`.
* Проверить, что для `WarehouseItem` скидка не опускает цену ниже минимума.
* Проверить `Reserve` при достаточном и недостаточном остатке.

---

### Задача 6: «Рисование фигур»

**Контекст:**
Нужно согласовать базовое «рисование» и масштабирование объектов на канве.

**Требования:**

1. Интерфейс **IDrawable**

* Свойства: `string Color`, `bool IsVisible`
* Метод: `string Draw()` — возвращает текстовое представление (для тестов).
* Реализация по умолчанию: если `IsVisible == false`, вернуть `"hidden"`, иначе `"drawn"`.

2. Интерфейс **IScalable**

* Свойства: `double Scale` (коэффициент),
* Метод: `void Resize(double factor)` — изменить масштаб.
* Реализация по умолчанию: `Scale *= factor`, если `Scale < 0`, установить `Scale = 0`.

3. Классы

* **Label** — реализует только `IDrawable`.
* **Rectangle** — реализует `IDrawable` и `IScalable`.

4. Реализация в классах

* Свойства — через приватные поля.
* В **Rectangle** переопределить `Draw()`, используя дополнительные свойства `double Width`, `double Height`, `double MinVisibleArea`:

  * эффективные размеры = `Width * Scale`, `Height * Scale`;
  * если `эффективная площадь < MinVisibleArea`, вернуть `"too small"` независимо от `IsVisible`;
  * иначе, если `IsVisible == false`, вернуть `"hidden"`;
  * иначе вернуть, например, `"rect W=..., H=..., color=..."`.
* `Label` использует дефолтный `Draw()`.

5. Тестовый код

* Создать `Label` и `Rectangle`, поиграться с `IsVisible`, `Resize()`.
* Показать, что маленький прямоугольник не рисуется из-за порога площади.

---

Отлично! Вот ещё **5 задач** в том же стиле (2 независимых интерфейса, дефолт-реализация в одном, один класс реализует только первый интерфейс, второй — оба и переопределяет метод с учётом доп. свойства).

---

## Задача 7: «Медиаплеер: треки и плейлисты»

**Контекст:**
Система воспроизведения аудио с базовыми треками и расширенным управлением плейлистами.

**Требования:**

1. Интерфейс **ITrack**

* Свойства: `string Title`, `int DurationSec`, `int PositionSec`.
* Метод: `void Seek(int seconds)` — перемотка на `seconds` вперёд.
* Реализация по умолчанию: `PositionSec = min(PositionSec + seconds, DurationSec)`.

2. Интерфейс **IPlaylist**

* Свойство: `int Count`.
* Метод: `void Add(ITrack track)` — добавить трек.

3. Классы

* **BasicTrack** — реализует только `ITrack`.
* **ManagedPlaylist** — реализует `ITrack` и `IPlaylist` (плейлист сам себя играет как большой трек).

4. Реализация

* Свойства через приватные поля.
* `BasicTrack` использует дефолтный `Seek`.
* В `ManagedPlaylist` добавьте `int CrossfadeSec` — длительность склейки.
* Переопределите `Seek(int seconds)` так:

  * При переходе через границу трека прибавляйте `CrossfadeSec` (симулируя склейку).
  * Не выходить за пределы общей длительности плейлиста (сумма длительностей + склейки между треками).
* `Count` — число добавленных треков; `Add` добавляет в список.

5. Тест

* Создать `BasicTrack` и `ManagedPlaylist` с несколькими треками и `CrossfadeSec`.
* Проверить `Seek` в пределах трека и при переходе между треками (склейка учитывается).
* Проверить `Add` и `Count`.

---

## Задача 8: «Ресторан: заказ и скидки»

**Контекст:**
Управление заказами и применение скидок для постоянных клиентов.

**Требования:**

1. Интерфейс **IOrder**

* Свойства: `string Customer`, `int TotalCents`.
* Метод: `void ApplyDiscount(int percent)`.
* Реализация по умолчанию: уменьшить `TotalCents` на `percent%`, не ниже 0.

2. Интерфейс **ILoyalty**

* Свойство: `int LoyaltyPoints`.
* Метод: `void AddPoints(int amount)`.

3. Классы

* **SimpleOrder** — реализует только `IOrder`.
* **MemberOrder** — реализует `IOrder` и `ILoyalty`.

4. Реализация

* Свойства через приватные поля.
* `SimpleOrder` использует дефолтный `ApplyDiscount`.
* В `MemberOrder` добавьте `int MinBillCents` — минимальный чек после скидки.
* Переопределите `ApplyDiscount` так, чтобы после скидки сумма не опускалась ниже `MinBillCents`.
* `AddPoints(amount)` увеличивает `LoyaltyPoints` на `amount`; при успешном применении скидки добавляйте бонус: `amount/10`.

5. Тест

* Создать `SimpleOrder` и `MemberOrder` с `MinBillCents`.
* Проверить, что у `MemberOrder` цена не падает ниже минимума.
* Проверить начисление `LoyaltyPoints`.

---

## Задача 9: «Уведомления и лимиты»

**Контекст:**
Система уведомлений с базовой отправкой и расширенным лимитом скорости.

**Требования:**

1. Интерфейс **INotification**

* Свойства: `string Message`, `bool Sent`.
* Метод: `void Send()` — отправить уведомление.
* Реализация по умолчанию: печатает в консоль и ставит `Sent = true`.

2. Интерфейс **IRateLimited**

* Свойство: `int PerMinuteLimit`.
* Метод: `bool TryConsume()` — попытка «потратить» один токен отправки.

3. Классы

* **PlainNotification** — реализует только `INotification`.
* **ThrottledNotification** — реализует `INotification` и `IRateLimited`.

4. Реализация

* Свойства через приватные поля.
* `PlainNotification` использует дефолтный `Send()`.
* В `ThrottledNotification` добавьте свойство `int UsedInCurrentMinute`.
* Переопределите `Send()` так:

  * Если `TryConsume()` вернул `true`, выполнить дефолтный `Send()`;
  * иначе — ничего не отправлять, `Sent` остаётся `false`.
* В `TryConsume()` увеличивать `UsedInCurrentMinute`, если не превышен `PerMinuteLimit`; предусмотреть метод для сброса счётчика (можно публичный `ResetWindow()`).

5. Тест

* Создать `PlainNotification` и `ThrottledNotification` с лимитом.
* Сделать несколько попыток отправки, проверить, что лимит соблюдается.
* Проверить сброс окна и повторные отправки.

---

## Задача 10: «Навигация и платные участки»

**Контекст:**
Маршрутизация по карте с базовой оценкой времени и расширенной поддержкой платных дорог.

**Требования:**

1. Интерфейс **IRoute**

* Свойства: `string From`, `string To`, `int DistanceKm`.
* Метод: `int EstimateMinutes(int avgSpeedKmh)`.
* Реализация по умолчанию: `ceil(DistanceKm * 60 / avgSpeedKmh)` (минимум 1 минута).

2. Интерфейс **ITollAware**

* Свойство: `int TollCount`.
* Метод: `int TotalTollCost()` — суммарная стоимость проезда.

3. Классы

* **SimpleRoute** — реализует только `IRoute`.
* **TollRoute** — реализует `IRoute` и `ITollAware`.

4. Реализация

* Свойства через приватные поля.
* `SimpleRoute` использует дефолтный `EstimateMinutes`.
* В `TollRoute` добавьте `int TollPricePerGate`.
* Переопределите `EstimateMinutes`:

  * К времени по умолчанию добавьте `TollCount * 2` минуты (замедление на воротах).
  * Не менее 1 минуты.
* `TotalTollCost()` = `TollCount * TollPricePerGate`.

5. Тест

* Создать `SimpleRoute` и `TollRoute` с разным `TollCount`.
* Сравнить оценки времени на одинаковой дистанции и скорости.
* Проверить `TotalTollCost()`.

---

### Примечания по стилю (для избежания штрафов)

* Используйте **PascalCase** для типов/свойств/методов, **camelCase** для приватных полей с `_` как префиксом по желанию (`_count`).
* Выносите числа в `const`/`static readonly` (например, `const int MaxRetries = 3;`).
* Держите строки <80 символов, длинные выражения переносите.
* Старайтесь, чтобы публичные методы принимали **интерфейсы**, а не конкретные классы.
* Чётко задавайте модификаторы доступа.
* Избегайте скрытых побочных эффектов — по возможности возвращайте значения и логируйте действия.
